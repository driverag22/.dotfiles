= Decorator =

- Uses object decomposition and delegation to extend the behavior of existing classes in a way that is both lightweight and flexible. Provides a way of attaching 
additional responsibilities to an object dynamically.

- Open-close principle: classes should be open for extension, but closed for modification.
- Decorator design pattern offers an alternative to class inheritance for extending the behavior of existing classes .Adding new features through subclasses complies 
with the open-closed principle, but the protected interface of the base class is exposed to the subclasses, inheritance tends to weaken the encapsulation barrier 
around the base class (known as fragile superclass problem). Moreover, if different combinations of features are valid it becomes messy (e.g.: subclass with feature A,subclass with feature B, subclass with feature A & B). Also creates a compile-time structural relationship between the features being added and the classes being 
extended.

- Especially useful when different combinations and permutations of features are permitted.

- Two main groups of classes, *concrete components* and *concrete decorators*. *Concrete components* contain the base functionality that is extended or decorated with features defined in the *concrete decorators*.

- To add a feature to a component, you create an instance of the component and pass this instance to the constructor for the decorator that defines the feature you 
want to add to the component.
- To a concrete component you can add (theoretically infinitely many) concrete decorators.
- Java I/O library based on decorator design pattern.


Both the Decorator and Adapter design patterns delegate to a wrapped object. The principle difference between the two patterns is Decorator adds new behavior without 
changing the interface whereas Adapter keeps the same basic behavior but changes the interface.
