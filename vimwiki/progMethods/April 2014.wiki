1. 
   i) It facilitates communcation about design of the program within a team.
   ii) It facilitates independent construction by a team (programming in parallel).
   iii) It facilitates testing of the different parts (modules) of the program.
   iv) It facilitates reusing certain modules of the program.
   v) It facilitates maintability of the program.

2. 
{{{java 
/**
 * Returns the average value in an array of integers.
 *
 * @param a   integer array to find the mean of 
 * @pre {@code a != null && a.length > 0}
 *
 * @post {@code \result == (\sum i; a.has(i); a[i])/a.length)}
 **** OR
 * @returns {@code (\sum i; a.has(i); a[i])/a.length)}
 *
 * @modifies None
 * @throws IllegalArgumentException if {@code a.length == 0}
 * @throws NullPointerException if {@code a == null}
 */
double mean(int[] a) throws IllegalArgumentException, NullPointerException {
     /****/
}
}}}

3. 
  - An exception can contain additional information.
  - All values might be possible as return values, making it impossible to have "special" return values.
  - Client code does not need to check for special return values and possibly propagate them up.
  - An exception cannot be ignored easily, but it is easier to forget checking for special values.

4. 
  - Helps stabilize contracts and interfaces before implementing them.
  - It encourages analysis of contracts and interfaces before implementing them.
  - When working on implementation, the programmer can focus completely on it instead of having to interlace it with test development.

5. Client code is dependent on abstraction instead of implementation, making it easier to change the implementation. Moreover, reusability is easier since the 
   encapsualted object is not dependent on external factors. 

6. ADT -> set of abstract values with the operations that can be performed on them. Its implementation is encapsualted, so the client code cannot access it, and is 
   not dependent on it.

7. 






