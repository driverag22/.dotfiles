1. 
  a) An ADT is an set of asbtract values together with operations that can be performed on those values. Its implementation is encapsulated and not
     directly accessible by client code, so the client code depends on the ADT and not the implementation.
  b) Since client code is dependent on the ADT and not the implementation, the implementation can be changed without affecting the correctness of the program (as long
     as the new implementation still follows the ADT). In addition, different implementations can be made for the same ADT, allowing the client to choose one 
     based on specific requiremenets such as memory limits.
  c) Code: data representation (based on concrete types or other ADTs), implementation of operations described by ADT.
     Documentation: representation invariant (defining when the data representation is valid), abstraction function mapping the valid data rep. to the abstract value.

2. 
  a) The _Composite_ design pattern has a tree-structure where the leaf nodes are single objects and the interior nodes are compositions of the child nodes. All of 
     the objects (nodes) share on common interface, so the clients can treat individual objects and compositions of objects the same.
  b) A single main interface which all the individual objects and composite objects will inherit from (extend). In particular, you can have any number of concrete 
     single objects, and a compound object, which is made up of 0 or more subtypes of the original interface.
     *Their answer*: The common interface is put in a common superclass from which all non-container components and container components inherit. A container node 
     contains zero or more components. Client code manipulated all components through the abstract container interface.
  c) Drawn in notebook.

3. 
  a) It is about the Decorator design pattern since the behavior is modified but not the interface.
  b) Code for duplicator...

4. 
  a) Drawn in notebook.
  b) Concrete observers are registered (by client or by themselves) with one or more concrete subjects. They can possibly be deregistered later as well. 
     Whenever a concrete subject is modified, it notifies (updates) all registered observers. If an observer needs further information from the subject, 
     it can pull that data (for that a reference to the concrete subject is required).
  c) There is a pull-versus-push tradeoff. Here, because the changes are small, the changes can be pushed. But observers need the ability to pull as well. 
     Hence, an observer needs to know the identity of the subject. Since an observer can observe multiple subjects at the same time, the identity of the 
     subject must be passed with the update call.
